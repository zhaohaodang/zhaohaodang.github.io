import{_ as a,c as s,o as i,a4 as t}from"./chunks/framework.BCqbIoqo.js";const y=JSON.parse('{"title":"ES6一问一答","description":"","frontmatter":{"title":"ES6一问一答","date":"2023-12-01T15:02:02.000Z","tag":"JavaScript","draft":true},"headers":[],"relativePath":"posts/2023/ES6一问一答.md","filePath":"posts/2023/ES6一问一答.md","lastUpdated":1752485935000}'),e={name:"posts/2023/ES6一问一答.md"},h=t(`<h2 id="对象的扩展" tabindex="-1">对象的扩展 <a class="header-anchor" href="#对象的扩展" aria-label="Permalink to &quot;对象的扩展&quot;">​</a></h2><h3 id="super关键字指向什么" tabindex="-1">super关键字指向什么？ <a class="header-anchor" href="#super关键字指向什么" aria-label="Permalink to &quot;super关键字指向什么？&quot;">​</a></h3><p>当前对象的原型对象</p><h3 id="super关键字表示原型对象时-有什么局限性" tabindex="-1">super关键字表示原型对象时，有什么局限性？ <a class="header-anchor" href="#super关键字表示原型对象时-有什么局限性" aria-label="Permalink to &quot;super关键字表示原型对象时，有什么局限性？&quot;">​</a></h3><p>只能用在函数方法中，用在其他地方会报错。目前，只有对象方法的简写法，才能让JavaScript引擎确认，定义的是对象的方法。</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">	say</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">		super</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="遍历对象的属性有哪几种方法" tabindex="-1">遍历对象的属性有哪几种方法？ <a class="header-anchor" href="#遍历对象的属性有哪几种方法" aria-label="Permalink to &quot;遍历对象的属性有哪几种方法？&quot;">​</a></h3><p>五种</p><ol><li>for…in…</li><li>Object.keys</li><li>getOwnPropertyNames</li><li>getOwnPropertySymbols</li><li>Reflect.ownKeys</li></ol><h3 id="object-create-、new-object-和-的区别" tabindex="-1"><strong><strong>Object.create()、new Object()和{}的区别？</strong></strong> <a class="header-anchor" href="#object-create-、new-object-和-的区别" aria-label="Permalink to &quot;****Object.create()、new Object()和{}的区别？****&quot;">​</a></h3><h3 id="什么是魔术字符串" tabindex="-1">什么是魔术字符串？ <a class="header-anchor" href="#什么是魔术字符串" aria-label="Permalink to &quot;什么是魔术字符串？&quot;">​</a></h3><p>是那些重复出现，和逻辑代码深度绑定的字符串。</p><h3 id="什么是柯里化-有哪些好处" tabindex="-1">什么是柯里化？有哪些好处？ <a class="header-anchor" href="#什么是柯里化-有哪些好处" aria-label="Permalink to &quot;什么是柯里化？有哪些好处？&quot;">​</a></h3><h3 id="this-绑定分为几种-在箭头函数里this指向什么" tabindex="-1">this 绑定分为几种？在箭头函数里this指向什么？ <a class="header-anchor" href="#this-绑定分为几种-在箭头函数里this指向什么" aria-label="Permalink to &quot;this 绑定分为几种？在箭头函数里this指向什么？&quot;">​</a></h3><h3 id="为什么会有变量提升-变量提升的利弊" tabindex="-1">为什么会有变量提升？变量提升的利弊 <a class="header-anchor" href="#为什么会有变量提升-变量提升的利弊" aria-label="Permalink to &quot;为什么会有变量提升？变量提升的利弊&quot;">​</a></h3><h3 id="尾调用函数优化是什么-实现的思路是什么" tabindex="-1">尾调用函数优化是什么？实现的思路是什么？ <a class="header-anchor" href="#尾调用函数优化是什么-实现的思路是什么" aria-label="Permalink to &quot;尾调用函数优化是什么？实现的思路是什么？&quot;">​</a></h3><h3 id="object-create-函数签名是什么" tabindex="-1">Object.create 函数签名是什么？ <a class="header-anchor" href="#object-create-函数签名是什么" aria-label="Permalink to &quot;Object.create 函数签名是什么？&quot;">​</a></h3><h3 id="获取symbol类型的属性名-有几种方法" tabindex="-1">获取symbol类型的属性名，有几种方法？ <a class="header-anchor" href="#获取symbol类型的属性名-有几种方法" aria-label="Permalink to &quot;获取symbol类型的属性名，有几种方法？&quot;">​</a></h3><p>Object.getOwnPropertySymbols Reflect.ownKeys，其他诸如Object.keys,for..in, for..of都获取不到</p><h3 id="在不同的iframe中都调用symbol-for-same-返回的值是否相等" tabindex="-1">在不同的iframe中都调用Symbol.for(”same”)，返回的值是否相等？ <a class="header-anchor" href="#在不同的iframe中都调用symbol-for-same-返回的值是否相等" aria-label="Permalink to &quot;在不同的iframe中都调用Symbol.for(”same”)，返回的值是否相等？&quot;">​</a></h3><p>是。Symbol.for在全局进行注册，可以在不同的 iframe 和 service worker 中取到同一个值。</p><h3 id="一些默认行为例如-instanceof-可以使用内置的symbol值改变instanceof的行为-请写下具体的实现。" tabindex="-1">一些默认行为例如 instanceof ,可以使用内置的Symbol值改变instanceof的行为，请写下具体的实现。 <a class="header-anchor" href="#一些默认行为例如-instanceof-可以使用内置的symbol值改变instanceof的行为-请写下具体的实现。" aria-label="Permalink to &quot;一些默认行为例如 instanceof ,可以使用内置的Symbol值改变instanceof的行为，请写下具体的实现。&quot;">​</a></h3><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	[Symbol.hasInstance](</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> foo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">instanceof</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">instanceof</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyClass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// true</span></span></code></pre></div><p>比如， foo instanceof Foo 在语言内部， 实际调用的是 <code>Foo[Symbol.hasInstance](foo)</code> 。</p><h3 id="concat的参数如果是数组会被展开吗-类数组呢" tabindex="-1">concat的参数如果是数组会被展开吗？类数组呢？ <a class="header-anchor" href="#concat的参数如果是数组会被展开吗-类数组呢" aria-label="Permalink to &quot;concat的参数如果是数组会被展开吗？类数组呢？&quot;">​</a></h3><p>数组会被展开，类数组不会被展开。可以修改Symbol.isConcatSpreadable属性控制是否可以展开。</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;a&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;b&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">].</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">concat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;c&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;d&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;a&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;b&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">].</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">concat</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({length:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;c&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;d&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// [&quot;a&quot;,&quot;b&quot;,{length:2,0:&quot;c&quot;,1:&quot;d&quot;}]</span></span></code></pre></div><h2 id="set-和-map数据结构" tabindex="-1">Set 和 Map数据结构 <a class="header-anchor" href="#set-和-map数据结构" aria-label="Permalink to &quot;Set 和 Map数据结构&quot;">​</a></h2><h3 id="使用-set-去掉数组的重复项" tabindex="-1">使用 Set 去掉数组的重复项 <a class="header-anchor" href="#使用-set-去掉数组的重复项" aria-label="Permalink to &quot;使用 Set 去掉数组的重复项&quot;">​</a></h3><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Array.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]))</span></span></code></pre></div><h3 id="set-实例的属性和方法" tabindex="-1">Set 实例的属性和方法 <a class="header-anchor" href="#set-实例的属性和方法" aria-label="Permalink to &quot;Set 实例的属性和方法&quot;">​</a></h3><p>属性 contructor size 方法 /add /has /delete /clear</p><h3 id="weakset的好处" tabindex="-1">WeakSet的好处 <a class="header-anchor" href="#weakset的好处" aria-label="Permalink to &quot;WeakSet的好处&quot;">​</a></h3><p>WeakSet中都是弱引用，垃圾回收机制想要回收一个对象，不会考虑WeakSet中是否有对改对象的引用，避免发生内存泄露的问题。</p><h3 id="map-数据结构相对于-object-有什么优势" tabindex="-1">Map 数据结构相对于 Object 有什么优势？ <a class="header-anchor" href="#map-数据结构相对于-object-有什么优势" aria-label="Permalink to &quot;Map 数据结构相对于 Object 有什么优势？&quot;">​</a></h3><p>Object本质是键值对的集合，但是只能用字符串当做键。Map 的键不限于字符串，各种类型的值都可以当做键</p><h3 id="和-map-相比-weakmap的主要区别是什么" tabindex="-1">和 Map 相比，WeakMap的主要区别是什么？ <a class="header-anchor" href="#和-map-相比-weakmap的主要区别是什么" aria-label="Permalink to &quot;和 Map 相比，WeakMap的主要区别是什么？&quot;">​</a></h3><ol><li>WeakMap没有遍历操作，也没有size属性，因为没法列出所有键名，某个键名是存在无法预测。</li><li>WeakMap 的键名只能接受对象，null也不行，symbol也不行。</li><li>无法清空，不支持clear方法。</li></ol><h2 id="proxy" tabindex="-1">Proxy <a class="header-anchor" href="#proxy" aria-label="Permalink to &quot;Proxy&quot;">​</a></h2>`,39),n=[h];function l(p,k,r,o,d,c){return i(),s("div",null,n)}const u=a(e,[["render",l]]);export{y as __pageData,u as default};
